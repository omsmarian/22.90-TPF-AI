%% Limpiar todo
clear; close all; clc;
%% 1. Leer imagen (Peter Corke)
img = iread("img/test1.png");
figure(1);
idisp(img);
title('Imagen original');

%% 7. DETECCIÓN DE VERDE (sobre imagen sin rojo)

img = igamm(img, 0.75);

I = img;

I(:,:,2) = niblack(I(:,:,2), -0.05, 5);

figure(10);
idisp(I);

HSV = rgb2hsv(I);

H = HSV(:,:,1);
S = HSV(:,:,2);
V = HSV(:,:,3);


%% 8. Realce de verde (clásico Corke)
green_enhanced = (H > 0.166 & H < 0.65) ... 
                & (S > 0.1 & S < 0.5);

kgaus = kgauss(5);

green_enhanced = iconv(green_enhanced,kgaus);
T = otsu(green_enhanced);
green_enhanced = green_enhanced > T;
green_enhanced = iclose(green_enhanced, strel('disk',2));
green_enhanced = iopen(green_enhanced, strel('disk',4));

figure(5)
idisp(green_enhanced)
title('Mascar Verde')

%% Detectar blobs con borde
rectangulo = iblobs(green_enhanced, 'class', 1, 'boundary');

figure;
imshow(green_enhanced);
axis image;
axis ij;
hold on;
title('Esquinas geométricas reales (intersección de rectas)');

corners = [];

for i = 1:length(rectangulo)

    b = rectangulo(i);

    % ===============================
    % PIXELES DEL BLOB (Corke-compatible)
    % ===============================

    % Bounding box del blob
    umin = b.umin; umax = b.umax;
    vmin = b.vmin; vmax = b.vmax;

    % Recortar máscara del blob
    submask = green_enhanced(vmin:vmax, umin:umax);

    % Coordenadas de píxeles del blob
    [yy, xx] = find(submask);
    pts = [xx + umin - 1, yy + vmin - 1];

    % Centroide real (no uses b.uc/b.vc, calculalo)
    c = mean(pts, 1);

    % Distancia al centroide
    d = hypot(pts(:,1) - c(1), pts(:,2) - c(2));

    % Seleccionar píxeles más extremos (vértice)
    tol = 0.97 * max(d);
    candidates = pts(d >= tol, :);

    % Vértice final
    corner = mean(candidates, 1);

    corners = [corners; corner];

    % Dibujar esquina REAL
    plot(corner(1), corner(2), 'ro', ...
        'MarkerSize', 14, ...
        'MarkerFaceColor', 'r');

    text(corner(1)+10, corner(2)+10, ...
        sprintf('%d', i), ...
        'Color','yellow', ...
        'FontSize',12, ...
        'FontWeight','bold');
end

hold off;

%% 9. Detección de bordes (Corke)
edges = icanny(green_enhanced, 1);


figure(7);
idisp(edges);
title('Bordes verdes');


%% 6. Transformada de Hough (Corke)
Hh = Hough(edges);


Hh.plot();

error('miau');

%% 2. Extraer canales RGB
R = img(:,:,1);
G = img(:,:,2);
B = img(:,:,3);

%% 3. Realce de rojo mejorado
red_enhanced = R - max(G, B);

%% 4. Umbral adaptativo para rojo
vals = red_enhanced(:);
vals = vals(vals > 0);
th = prctile(vals, 98);
fprintf('Umbral calculado: %.4f\n', th);

%% 5. Máscara de rojo
red_mask = red_enhanced > th;
se = kcircle(9);
red_mask = iclose(red_mask, se);
red_mask = iopen(red_mask, se);

%% 6. Eliminar línea roja
img_masked = img;
img_masked(:,:,1) = img_masked(:,:,1) .* ~red_mask;
img_masked(:,:,2) = img_masked(:,:,2) .* ~red_mask;
img_masked(:,:,3) = img_masked(:,:,3) .* ~red_mask;
figure(2);
idisp(img_masked);
title('Imagen sin línea roja');

function [dir, p0] = fitLinePCA(P)
    p0 = mean(P,1);
    C = cov(P);
    [V, D] = eig(C);
    [~, i] = max(diag(D));
    dir = V(:,i)';
end

function p = intersectLines(p1, d1, p2, d2)
    A = [d1(:) -d2(:)];
    b = (p2 - p1)';
    t = A\b;
    p = p1 + t(1)*d1;
end